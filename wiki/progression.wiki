= Introduction =

Ce projet est réalisé par des étudiants pour une majeur en conception de jeux vidéos à l'Université du Québec À Chicoutimi (UQAC).<br>
La date d'échéance de ce projet est avant le *25 avril 2012*.


= Description du Projet =

Comme projet, nous avons pensé à réaliser un jeu vidéo de tir multidirectionnel où le joueur doit  survivre à une invasion de morts-vivants. Le but du jeu est d’éliminer tous les morts-vivants dans un niveau fixe. Plus le joueur réussit de niveaux, plus le niveau de difficulté augmente. Par exemple, lors de la progression, il y a de nouveaux morts-vivants avec des pouvoirs différents et il y en a davantage par niveau. Le joueur peut acquérir de nouvelles armes pour augmenter ses chances de survie dans chaque niveau. De plus, nous avons pensé à intégrer la possibilité de jouer en coopération avec des amis dans notre jeu en réseau, cependant le jeu étant d’une grande ampleur, il est possible que cette fonctionnalité ne soit pas réalisé.

= Hello World... Tout à un commencement = 

Puisque nous commençons dans l'univers du jeu vidéo, il va de soit que des tests seront effectués. Tout d'abord, nos premiers tests constituent un élément de familiarisation avec XNA Game Studio.
<br/>
Voici les tests qui ont été effectué:
  * Faire afficher une chaîne de caractère à l'écran et l'animé pour que ce ne soit pas que du texte brute;
  * Faire affichier des sprites et les faire bouger sur la fenêtre de jeu;
  * Prochaine étape: Animé les sprites à l'aide de SpriteSheet.

= La structure du programme = 

Pour le bon fonctionnement du programme, une bonne analyse doit être faite. Avec le peu de développement que nous avons effectués, nous avons réalisé le diagramme de classe. Ce diagramme à été conçu avec le peu d'expérience dans XNA que l'équipe dispose. Cependant, les données à conservé au niveau des objets est du pareil au même peu importe le langage de programmation.
<br />
Le diagramme de classe est disponible à l'adresse suivante: <a href="http://dl.dropbox.com/u/15342998/The_Apocalypse.vsd">lien</a>

= L'envoie de projectile (Principe) =

Le principe d'envoyer un projectile dans tout jeux vidéo est exprimé selon des formules mathématiques. Puisque la balle est vu comme étant un point sur un plan cartésien où le X et le Y sont strictement positive. Soit la balle dessine une formule de degrée 1 (Une Droite de forme Y = MX + B).


Soit M la pente que la balle parcourera dans l'espace du jeu.
Soit X la position sur laquel la balle se déplacera.
Il est important de prendre note qu'une droite n'ayant aucune pente doit avoir la même vitesse qu'une pente incliné ou complètement vertical.
Soit B la valeur de Y lors que X = 0.

La variable M se calcul très simplement par la formule du taux de variation qui va comme suit:

<pre>
     △Y    Position_souris_Y - Position_joueur_Y
M = ---- = --------------------------------------
     △X    Position_souris_X - Position_joueur_X
</pre>

Maintenant que la pente est trouvé, il est possible de trouvé la valeur de B:

<pre>
B = Position_joueur_Y - (M * Position_joueur_X)
</pre>

Maintenant que M et B sont trouvé, la trajectoire de la balle est connus. Il faut trouvé de quel côté la balle doit parcourir cette trajectoire:


<pre>
Le joueur regarde à gauche si:
Position_souris_X - Position_joueur_X est vrai quand le résultat est < 0
Le joueur regarde à droite si la première condition est fausse.
</pre>

Simplement faire incrémenter le X pour faire avancé la balle ne donnera pas de bon résultat. Il va de soit pour couvrir la totalité d'un cercle il faut utilisé la trigonométrie. Si l'on connait l'angle en radian de notre droite. Il ne suffit que de faire le COS et le SIN de celui-ci pour obtenir ses coordonnées cartésienne.
Le calcul de l'angle se fait à la tangante de la division entre 2 points de la droite.

<img src="http://dl.dropbox.com/u/15342998/trigo.png" />

= Animation du texte =

L'animation d'un texte avec XNA est fort simple. Tout d'abord vous avez besoin de deux variables. L'une composé du texte souhaité et l'une contenant la chaîne de caractère à affiché. Le but est d'affiché les lettres une par une tant que la phrase souhaité n'est pas complètement affiché. Nous allons donc se servir des 2 chaînes de caractère et transférer à un interval régulier chacun des caractères de la variable contenant la phrase complète vers celle qui sera affiché.

= Les paramètres =

Les paramètres sont l'endroit oû toutes les variables pouvant être modifiées sont regroupées. Cette fonctionnalité doit être disponible à tout moment et sert par la même occasion de menu pause. Le jeu est complètement interrompu lorsque cette fenêtre est activé. Les paramètres retrouvés sont:
  * Le nom du joueur(15 caractère maximum)
  * Le volume du jeu(0% à 100%)
  * La balance(-100% à 100%)
  * Le pitch(-100% à 100%) Ce paramètre est un supplément facultatif et amusant.
  * La contraste (0 à 255)
  * La luminosité (50 à 255)
  * Activer/Désactiver le mode plein écran

= Intelligence Artificiel =

Cette étape est crucial au projet, c'est grâce à elle que le jeu base son univers de jeu de survie. L'intelligence artificiel est ce qui rend les mort-vivants intelligents. Par intelligent, on sous-entend faire ce qu'un mort-vivant doit faire, soit courir après un être vivants doté d'un cerveau fonctionnel, il est clair qu'un mort-vivant n'a rien dans le crâne. Le but du patron de conception Observateur est justement de faire en sorte que le mort-vivant entreprenne son seul et unique travail, c'est-à-dire poursuivre le joueur jusqu'à sa mort.
<br/>
===Comment est-ce que le patron de conception fonctionne?===
Très simple, il suffit d'avoir un sujet et un observateur. Où le sujet dans notre cas est le joueur et l'observateur le zombie. Dès qu'une action qui doit faire réagir les morts-vivants est entreprise par le joueur, ceux-ci doivent réagir à cette action. Dans le cas présent, dès que le joueur bouge, ne serait-ce que d'un nanomètre, le mort-vivant doit en être informé pour se redirigé vers ca cible. Cette information est transmise via une fonction appelé Notify pour Notification qui elle se charge d'appelé une fonction dans chacun des morts-vivants pour mettre à jour les données de positionnement du joueur.

===Comment le joueur peut parler directement aux mort-vivants?===
Bonne question, c'est grâce à la fonction Attach(Observer) qui en d'autre terme signifie, attaché un observateur. Le joueur à une liste de monstre dans sa classe. La fonction Detach(Observer), retire de la liste l'observateur souhaité. Cependant, ce n'est pas l'objet lui même qui est transférer et stocké dans le joueur. Ce n'est qu'un référencement pour appeler des méthodes sans aucune variable. Le monstre à lui aussi un joueur pour savoir le positionnement.

===Concrètement, que se passe-t-il?===
Si le joueur, ne bouge pas la fonction Notify ne sera pas appelé et les morts-vivants ne changeront pas leur cible, qui est au coordonné déjà enregistré. Cependant, dès que le joueur bougera, la fonction Notify va être appelé et celle-ci va faire appel à tous les morts-vivants pour leurs dirent, en quelque sorte, de changer de trajectoire puisqu'elle n'est plus valide.

===Pourquoi ne pas juste transférer les valeurs par le niveau?===
Les ressources! Si l'on fait cela, on ne sait jamais quand le joueur va bouger sauf si l'on garde des coordonnés en variable dans la classe. Si nous suivons un principe OO (Orienté Objet), ce n'est pas à la classe Niveau de prendre le positionnement du joueur en variable. De plus faire cela, reviendrais à dupliquer les valeurs et prendre davantage d'espace mémoire. Avec le principe d'Observateur, le programme fait seulement les calculs lorsque s'en est vraiment nécessaire. Ainsi, nous gagnons en puissance et plus de monstres peuvent être généré pour la cause.
<br/>
Pour comprendre l'observateur voici un lien l'expliquant:
<a href="http://www.dofactory.com/Patterns/PatternObserver.aspx">Observateur (Anglais)</a>